---
title: Rust所有权与借用
tags: 
  - 编程
  - Rust
  - 计算机
category: Rust
---
### 引入

观察以下代码，并运行以下代码。

代码 [1]

```rust
let name = String::from("Hello World!!")
let name1 = name

println!("{}", name);
```

我们会发现运行会无法通过，再观察以下代码，并运行它。

代码 [2]

```rust
let i = 123
let i1 = i
println!("{}", i)
```

观察以上代码，并运行测试，发现效果和前面的代码效果不一样，这个代码竟然能够奇迹般的运行。这里之后我们需要引入一个概念，叫做 `所有权`。

### 解析

以上代码就是Rust经典的所有权问题，什么是所有权？

所有权是Rust中保证内存安全的核心概念之一，至于下文讲到的借用也是。

#### 所有权的基本规则

- 每个值都有一个所有者
- 一次只能有一个所有者
- 当所有者离开作用域时，值将被丢弃

了解玩所有权的基本规则后，我们就可以知道本文开头的代码[1]为什么报错了，是因为给s2赋值的时候，s1的所有权已经全部转移到s2了，这时候s1是个空变量，所以就这么报错了。但是为什么代码[2]没有报错，这里我们需要引入两个概念了 `移动语义Move` 和 `复制语义Copy`。

#### 移动语义

移动语义一般是将所有权直接转移到目标手中，这一特性导向的结果就是源值不再有效 (编译器阻止访问)，在Rust中移动语义是默认实现的，除非你的类型实现了复制语义。

#### 复制语义

复制语义一般是直接创建一个独立的新副本，相比移动语义，复制语义能访问源值。在Rust中复制语义是需要实现Copy trait，即为 `#[derive(Copy, Clone)]` 同时如果里面的类型没有实现复制语义的类型的话，会报错。所以实现复制语义前提是相关类型不能有一个为移动语义。

了解以上的概念后我们看String结构体类型的代码，可以看到：

代码 [3]

```rust
#[derive(PartialEq, PartialOrd, Eq, Ord)]
#[stable(feature = "rust1", since = "1.0.0")]
#[lang = "String"]
pub struct String {
    vec: Vec<u8>,
}
```

String结构体位实现复制语义，所以在为新变量赋值的时候调用String类型的变量需要添加 `&` 符号。

同时代码 [2] 中因为 i32 为默认的复制语义所以，在调用时不需要添加 `&` 符号。

经典的复制语义类型是（当然讲的不太明白，需要自行查询资料）：

- 基本标量类型 (比如: i32，i64，bool)
- 复合类型Tuple，Array（前提内容不能包含非复制语义的元素）
- 指针类型（有点杂，后面讲）
- 标准库中的常见复制语义类型（Option和Result等，但是前提要包含的类型是复制语义的）
- 自定义的复制语义类型
- 切片 &[T] 与 字符串切片 &str
- 不包含移动语义的闭包类型

### 借用

借用在Rust中也是一个保证内存安全的核心概念。

借用的表示方式

```rust
let i = &var // 不可变引用
let i &mut var // 可变引用
```

上文说到借用类型也是一个复制语义类型，它临时借用了var变量的访问权，前提var不是复制语义，在不取得所有权访问该变量，借用结束后，所有权依旧归所有者所有。

#### 借用的基本规则

- 只能有任意数量的不可变引用，或者只有一个可变引用
- 引用必须始终有效

#### 借用与所有权的对比

- 所有权上，借用不能获取所有权，但是所有权可以获取所有权
- 源变量是由有效上，借用源变量有效，而所有权源变量转移后无效
- 内存安全上，借用负责释放内存，而所有权不负责释放内存
- 并发上，借用需要检查其保证，而所有权需要同步
- 性能上，借用仅传递指针，而所有权可能移动数据
- 使用场景上，借用一般用于只读或者临时的值修改，所有权用于需要所有值时
